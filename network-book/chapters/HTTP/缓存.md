# [缓存](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ)

- [http 协商缓存 VS 强缓存](https://www.cnblogs.com/wonyun/p/5524617.html)
- [浏览器缓存详解:expires,cache-control,last-modified,etag 详细说明](http://blog.csdn.net/eroswang/article/details/8302191)

## 缓存方式

- 浏览器缓存
- 代理缓存
- 网关缓存
- CDN 缓存
- 反向代理缓存
- 负载均衡器缓存(部署在服务器上)

## 浏览器缓存示意图

- 浏览器第一次请求
  ![浏览器第一次请求](./imgs/浏览器第一次请求.png)

- 浏览器后续请求
  ![浏览器后续请求](./imgs/浏览器后续请求.png)

## 强制缓存、协商缓存

- 强制缓存 vs 协商缓存

| @                  | 强制缓存                                  | 协商缓存                                               |
| ------------------ | ----------------------------------------- | ------------------------------------------------------ |
| 状态码             | 200                                       | 304                                                    |
| 发送请求到服务器   | 否，直接从缓存取                          | 是，正如其名，通过服务器来告知缓存是否可用             |
| 相关的 header 字段 | `cache-control：max-age=number` `expires` | `Etag/If-None-Match` `Last-Modified/If-Modified-Since` |

- Etag/If-None-Match 协商缓存方案相对于 Last-Modified/If-Modified-Since 方案的优势：

  - 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新 GET；
  - 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说 1s 内修改了 N 次)，If-Modified-Since 能检查到的粒度是 s 级的，这种修改无法判断(或者说 UNIX 记录 MTIME 只能精确到秒)；
  - 某些服务器不能精确的得到文件的最后修改时间

- 用户的行为对缓存的影响

| 用户行为         | 强制缓存是否有效 | 协商缓存是否有效 |
| ---------------- | ---------------- | ---------------- |
| 地址栏回车       | ✅               | ✅               |
| 页面链接跳转     | ✅               | ✅               |
| 新开窗口         | ✅               | ✅               |
| 前进后退         | ✅               | ✅               |
| f5 刷新          | ❌               | ✅               |
| ctrl+f5 强制刷新 | ❌               | ❌               |

## Vary 缓存

> 当缓存服务器收到一个请求，只有当前的请求和原始（缓存）的请求头跟缓存的响应头里的`Vary指定的头部信息`都匹配，才能使用缓存的响应；
> 也就是说`Vary指定的头部信息`改变后，缓存就不生效了：如使用 Vary: User-Agent 头，当浏览器开发者模式在移动端和 pc 端切换的时候，就不会使用缓存了；
