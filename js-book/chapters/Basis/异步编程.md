# 异步编程

## Promises

--------------------------------------------------------------------------------

### Promise示例

```javascript
new promise((resolve, reject) => {
  a(getResultFromA, (aResult, err) => {
    if (!err) resolve(aResult) else reject(err)
  })
})
.then(data => {
  return new Promise((resolve, reject) => {
    b(getResultFromB, (bResult, err) => {
      if (!err) resolve(bResult) else reject(err)
    })
  }
})
.then(data => {
  return new Promise((resolve, reject) => {
    c(getResultFromC, (cResult, err) => {
      if (!err) resolve(cResult) else reject(err)
    })
  }
})
.then(data => {
  // do something
})
.catch(err => {
  throw err
})
```

### 返回不完整的Promise

```javascript
function hehe() {
  return Promise.resolve('hehehe');
}
function haha() {
  return Promise.reject('hahaha');
}
hehe().then((param) => {
  console.log(param);
})
haha().then((param) => {
  console.log(param + '111');
}).catch((param) => {
  console.log(param);
})
```

### 同时提供回调函数和 Promise 接口

```javascript
function foo(cb) {  
  if (cb) {
    return cb();
  }
  return new Promise(function (resolve, reject) {

  });
}
```

## generator

###  generator 示例

```javascript
function* gen() {
  var a = yield 'start';
  console.log(a);
  var b = yield 'end';
  console.log(b);
  return 'over';
}
var it = gen();

console.log(it.next()) // { value: 'start', done: false }
console.log(it.next(2)) // 2 { value: 'end', done: false }
console.log(it.next(3)) // 3 { value: 'over', done: true }
```

--------------------------------------------------------------------------------

## async/await

--------------------------------------------------------------------------------

- [async 函数的含义和用法](http://www.ruanyifeng.com/blog/2015/05/async.html)

### 基础使用

```javascript
async function () {
  try {
    const aResult = await new Promise(/* getResultFromAPromise */)
    const bResult = await new Promise(/* getResultFromBProimse */)
    const cResult = await new Promise(/* getResultFromCPromise */)
    // do something
  } catch (err) {
    throw err
  }
}
```

### 并行执行

```javascript
//延时n毫秒
function timeout(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}
function consoleNum() {
  let nums = [1, 2, 3, 4, 5, 6, 7, 8, 9];
  nums.forEach(async function(num) {
    await timeout(2000);
    console.log(num);
  });
}
consoleNum();
```

### 串行执行

```javascript
//延时n毫秒
function timeout(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}
async function consoleNum() {
  let nums = [1, 2, 3, 4, 5, 6, 7, 8, 9];
  for (let num of nums) {
    await timeout(2000);
    console.log(num);
  }
}
consoleNum();
```

### async并行的问题

```javascript
// 能不能做到遍历出false的时候就不再遍历了？
function timeout(ms) {
  return new Promise((resolve, reject) => {
    if(ms === 5000) {
      setTimeout(reject, ms);
    } else {
      setTimeout(resolve, ms);
    }
  });
}
let numList = [1, 2, 3, 4, 5, 6, 7, 8, 9];
let promiseList = numList.map((num) =>
  (async function() {
    try {
      await timeout(num * 1000);
      return true;
    } catch (err) {
      //这里出现错误后就没必要再继续遍历了
      return false;
    }
  })()
);
(async() => {
  let results = await Promise.all(promiseList);
  console.log(results);// [true, true, true, true, false, true, true, true, true]
  //根据numList的遍历结果决定下一步的执行逻辑......
  //只results中全为true才继续执行
})();
```

- timeout为何没有延时？

```javascript
function timeout(ms) {
  return new Promise((resolve, reject) => {
    if (ms === 500) {
      reject(ms);
    } else {
      setTimeout(resolve(ms), ms);
    }
  });
}
let numList = [1, 2, 3, 4, 5, 6, 7, 8, 9];
let promiseList = numList.map((num) => {
  return new Promise((resolve, reject) => {
    (async function() {
      try {
        let ms = await timeout(num * 1000);
        resolve(ms);
      } catch (err) {
        reject(err);
      }
    })()
  });
});
Promise.all(promiseList).then((data) => {
  console.log(data);
}, (err) => {
  console.log(err);
})
```
