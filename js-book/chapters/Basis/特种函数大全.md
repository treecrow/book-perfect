# 特种函数大全

## 概览

| 方法       | more |
|----------|------|
| 组合多个函数   | -    |
| 只执行一次的函数 | -    |
| 节流函数     | -    |
| 获取函数参数名  | -    |
| 彻底冻结对象   | -    |
| 斐波那契数列   | -    |

## 代码

- 组合多个函数(第一个函数运行的结果传给第二个)

```javascript
function composFn(...fns) {
    return (x) => fns.reduce((pre, cur) => cur(pre), x);
}
```

- 只执行一次的函数

```javascript
function once(fn, context) {
    let result;
    return function() {
        if(fn) {
            result = fn.apply(context || this, arguments);
            fn = null;
        }
        return result;
    };
}
```

- 节流函数: [JavaScript 节流函数 Throttle 详解](http://web.jobbole.com/86710/)

```javascript
function throttle(fn, delay, atleast) {
    let timer = null,
        previous = null;
    return function () {
        let now = +new Date();
        if (!previous) previous = now;
        if (atleast && now - previous > atleast) {
        fn();
        previous = now;
        clearTimeout(timer);
        } else {
        clearTimeout(timer);
        timer = setTimeout(function () {
            fn();
        }, delay);
        }
    }
}
```

- 获取函数参数名

```javascript
function getFunArgs(func) {
    // 首先匹配函数括弧里的参数
    var args = func.toString().match(/function\s.*?\(([^)]*)\)/)[1];

    // 分解参数成数组
    return args.split(",").map(function(arg) {
        // 去空格和内联注释
        return arg.replace(/\/\*.*\*\//, "").trim();
    }).filter(function(arg) {
        // 确保没有undefineds
        return arg;
    });
}
```

- 彻底冻结对象

```javascript
function deepFreeze(obj) {
    Object.freeze(obj);
    Object.keys(obj).forEach((key, value) => {
        if (typeof obj[key] === 'object') {
            deepFreeze(obj[key]);
        }
    });
}
```

- 斐波那契数列

```javascript
// 方法一(性能问题)
function fibonacci(n){
   if(n==0)return 0
   else if(n==1)return 1
   else return fibonacci(n-1) + fibonacci(n-2)
}
// 方法二(状态变量太多)
function fibonacci(n){
  var last = 1
  var last2 = 0
  var current = last2
  for(var i=1;i<=n;i++){
    last2 = last
    last = current
    current = last + last2
  }
  return current
}
// 方法三(用闭包函数的参数存储计算值，避免了重复计算)
function fib(n){
   function fib_(n,a,b){
       if(n==0)  return a
       else return fib_(n-1,b,a+b)
   }
   return fib_(n,0,1)
}
```

- [bind()函数](https://segmentfault.com/a/1190000002662251)

```javascript
Function.prototype.bind = function(context){
  self = this;  //保存this，即调用bind方法的目标函数
  return function(){
      return self.apply(context,arguments);
  };
};
```
