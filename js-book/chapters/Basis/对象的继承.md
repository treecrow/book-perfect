## 对象的继承

### 原型链
```js
//解决：
//问题：包含引用类型值的原型属性会被所有实例（原型链的下一级）共享（同原型模式）

function SuperType(){
    this.colors=["red","blue","green"];
}
function SubType(){}
SubType.prototype=new SuperType();
var instance1=new SubType();
instance1.colors.push("black");
alert(instance1.colors); //"red","blue","green","black"
var instance2=new SubType();
alert(instance2.colors); //"red","blue","green","black"
```

### 借用构造函数（很少使用）
```js
//解决：原型链所有实例共享原型属性的问题
//问题：方法都在构造函数中定义，函数复用无从谈起

function SuperType(){
    this.colors=["red","blue","green"];
}
function SubType(){
    SuperType.call(this); //继承了SuperType
}
var instance1=new SubType();
var instance2=new SubType();
instance1.colors.push("black");
alert(instance1.colors); //"red,blue,green,black"
alert(instance2.colors); //"red,blue,green"
```

### 组合继承（伪类经典继承）
```js
//解决：避免了原型链和借用构造函数的缺陷，融合了它们的优点，是JS中最常用的继承模式
//问题：会调用两次超类型构造函数

function Box(name,age){
    this.name=name;
    this.age=age;
    this.family=["哥哥","姐姐","妹妹"];
}
Box.prototype.run=function(){
    return this.name+this.age+"运行中.....";
};
function Desk(name,age){
    Box.call(this,name,age); //对象冒充
}
Desk.prototype=new Box();
var desk=new Desk("lee",100);
alert(desk.run());
```

### 原型式继承
```js
//解决：
//问题：

var person={
    name:"Nicholas",
    friends:["Shelby","Court","Van"]
};
var anotherPerson=Object.create(person,{
    name:{value:"Greg"}
});
alert(anotherPerson.name); //"Greg"
```

### 寄生式继承
```js
//解决：
//问题：

function createAnother(original){
    var clone=object(original); //通过调用函数创建一个新对象
    clone.sayHi=function(){  //以某种方式来增强这个对象
        alert("hi");
    };
    return clone; //返回这个对象
}
var person={
    name:"Nicholas",
    friends:["Shelby","Court","Van"]
};
var anotherPerson=createAnother(person);
anotherPerson.sayHi(); //"hi"
```

### 寄生组合式继承 （借用构造函数来继承属性，通过原型链的混成形式来继承方法）
```js
//解决：组合继承多次调用超类型构造函数的问题
//问题：

function inheritPrototupe(subType,superType){
    var prototype=object(superType.prototype); //创建对象（创建超类型原型的一个副本）
    prototype.constructor=subType; //增强对象（为创建的副本添加constructor属性,从而弥补因重写原型而失去的默认的constructor属性）
    subType.prototype=prototype; //指定对象（将新创建的对象（即副本）复制给子类型的原型）
}
function SuperType(name){
    this.name=name;
    this.colors=["red","blue","green"];
}
SuperType.prototype.sayName=function(){
    alert(this.name);
};
function SubType(name,age){
    SuperType.call(this,name);
    this.age=age;
}
inheritPrototupe(subType,superType);
SubType.prototype.sayAge=function(){
    alert(this.age);
};
```
